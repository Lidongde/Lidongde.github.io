<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[单片机单个按键扫描]]></title>
    <url>%2Fpost%2F8051-stc89c52-SingleKey.html</url>
    <content type="text"><![CDATA[一种最为简单的识别方式，用延时函数实现消抖处理，使用while死循环实现按键结束的判断！存在逻辑上的bug，不建议在实际项目中使用。 首先上链接！这是源文章的来源。 sbit s4 = P3^3; //单独使用一个I/O口，需要使用sbit进行位定义 void main() { while(1) { if(s4 == 0) //检测是否有键按下 { delay10ms(); //10ms延时函数进行消抖 if(s4 == 0) { dspbuf[0]++; while(!s4); //等待按键松开 } } display(); } } Warning: 在等待按键松开的过程中，如果按键长时间按下，程序会卡死在while(!s4)这一行。 解决方法： 1，改变按键的扫描方式！2，将功能实现代码放入到中断中去，例如这里的display函数。]]></content>
      <categories>
        <category>mcu-51</category>
      </categories>
      <tags>
        <tag>stc89c52</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经验-f12的妙用]]></title>
    <url>%2Fpost%2Ff12-an-useful-key.html</url>
    <content type="text"><![CDATA[本文链接！ 文章来源于百度经验，经验这个网站有些时候还是很有作用的，客观来讲baidu在某些场合不错的。 1首先,在自己喜欢的博客页面,点击鼠标右键,看到如下图片,点击检查.步骤阅读2然后,在右边的源码里边,找到”article_content”标签头,可以看到左侧部分的预览界面被选中的部分就是要复制粘贴文章(包括html部分),检查左侧被选中的部分是否是自己想要的部分.步骤阅读3之后,再右键选择该标签(“article_content”),如下图,选择Copy element复制(或者Cut element 剪切)该标签下的所有元素步骤阅读4最后,在自己博客的下”MarkDown编辑器”粘贴即可完全复制别人的博客步骤阅读5最后结果显示步骤阅读END]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>网页文章搬运</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转-小程序实现原理]]></title>
    <url>%2Fpost%2Fnull.html</url>
    <content type="text"><![CDATA[原文链接！ 因为课程作业的需要，选择了“微信小程序的原理与设计”这个题目，不多说了，开干吧！ 作为一名前端开发，如果你还停留在应用开发层面，那你就OUT了，快来跟我一起探讨下小程序框架本身底层实现的一些技术细节吧，让我们从小程序的运行机制来深度了解小程序。 小程序是基于WEB规范，采用HTML,CSS和JS等搭建的一套框架，微信官方给它们取了一个很牛逼的名字：WXML,WXSS，但本质上还是在整个WEB体系之下构建的。 WXML，个人猜测在取这个名字的是微信的Xml，说到底就是xml的一个子集。WXML采用微信自定义的少量标签WXSS，大家可以理解为就是自定义的CSS。实现逻辑部分的JS还是通用的ES规范，并且runtime还是Webview（IOS WKWEBVIEW, ANDROID X5）。 小程序 小程序目录结构 一个完整的小程序主要由以下几部分组成： 一个入口文件：app.js 一个全局样式：app.wxss 一个全局配置：app.json 页面：pages下，每个页面再按文件夹划分，每个页面4个文件 视图：wxml，wxss 逻辑：js，json（页面配置，不是必须） 注：pages里面还可以再根据模块划分子目录，孙子目录，只需要在app.json里注册时填写路径就行。 小程序打包 开发完成后，我们就可以通过这里可视化的按钮，点击直接打包上传发布，审核通过后用户就可以搜索到了。 那么打包怎么实现的呢？ 这就涉及到这个编辑器的实现原理和方式了，它本身也是基于WEB技术体系实现的，nwjs+react，nwjs是什么：简单是说就是node+webkit，node提供给我们本地api能力，而webkit提供给我们web能力，两者结合就能让我们使用JS+HTML实现本地应用程序。 既然有nodejs，那上面的打包选项里的功能就好实现了。 ES6转ES5：引入babel-core的node包 CSS补全：引入postcss和autoprefixer的node包（postcss和autoprefixer的原理看这里） 代码压缩：引入uglifyjs的node包 注：在android上使用的x5内核，对ES6的支持不好，要兼容的话，要么使用ES5的语法或者引入babel-polyfill兼容库。 打包后的目录结构 小程序打包后的结构如下： 所有的小程序基本都最后都被打成上面的结构 1、WAService.js 框架JS库，提供逻辑层基础的API能力 2、WAWebview.js 框架JS库，提供视图层基础的API能力 3、WAConsole.js 框架JS库，控制台 4、app-config.js 小程序完整的配置，包含我们通过app.json里的所有配置，综合了默认配置型 5、app-service.js 我们自己的JS代码，全部打包到这个文件 6、page-frame.html 小程序视图的模板文件，所有的页面都使用此加载渲染，且所有的WXML都拆解为JS实现打包到这里 7、pages 所有的页面，这个不是我们之前的wxml文件了，主要是处理WXSS转换，使用js插入到header区域。 小程序架构 微信小程序的框架包含两部分View视图层、App Service逻辑层，View层用来渲染页面结构，AppService层用来逻辑处理、数据请求、接口调用，它们在两个进程（两个Webview）里运行。 视图层和逻辑层通过系统层的JSBridage进行通信，逻辑层把数据变化通知到视图层，触发视图层页面更新，视图层把触发的事件通知到逻辑层进行业务处理。 小程序架构图： 小程序启动时会从CDN下载小程序的完整包，一般是数字命名的,如：_-2082693788_4.wxapkg 小程序技术实现 小程序的UI视图和逻辑处理是用多个webview实现的，逻辑处理的JS代码全部加载到一个Webview里面，称之为AppService，整个小程序只有一个，并且整个生命周期常驻内存，而所有的视图（wxml和wxss）都是单独的Webview来承载，称之为AppView。所以一个小程序打开至少就会有2个webview进程，正式因为每个视图都是一个独立的webview进程，考虑到性能消耗，小程序不允许打开超过5个层级的页面，当然同是也是为了体验更好。 AppService 可以理解AppService即一个简单的页面，主要功能是负责逻辑处理部分的执行，底层提供一个WAService.js的文件来提供各种api接口，主要是以下几个部分： 消息通信封装为WeixinJSBridge（开发环境为window.postMessage, IOS下为WKWebview的window.webkit.messageHandlers.invokeHandler.postMessage，android下用WeixinJSCore.invokeHandler） 1、日志组件Reporter封装 2、wx对象下面的api方法 3、全局的App,Page,getApp,getCurrentPages等全局方法 4、还有就是对AMD模块规范的实现 然后整个页面就是加载一堆JS文件，包括小程序配置config，上面的WAService.js（调试模式下有asdebug.js），剩下就是我们自己写的全部的js文件，一次性都加载。 在开发环境下 1、页面模板：app.nw/app/dist/weapp/tpl/appserviceTpl.js 2、配置信息，是直接写入一个js变量，__wxConfig。 3，其他配置 线上环境 而在上线后是应用部分会打包为2个文件，名称app-config.json和app-service.js，然后微信会打开webview去加载。线上部分应该是微信自身提供了相应的模板文件，在压缩包里没有找到。 1、WAService.js（底层支持） 2、app-config.json（应用配置） 3、app-service.js（应用逻辑） 然后运行在JavaScriptCore引擎里面。 AppView 这里可以理解为h5的页面，提供UI渲染，底层提供一个WAWebview.js来提供底层的功能,具体如下： 1、消息通信封装为WeixinJSBridge（开发环境为window.postMessage, IOS下为WKWebview的window.webkit.messageHandlers.invokeHandler.postMessage，android下用WeixinJSCore.invokeHandler） 2、日志组件Reporter封装 3、wx对象下的api，这里的api跟WAService里的还不太一样，有几个跟那边功能差不多，但是大部分都是处理UI显示相关的方法 4、小程序组件实现和注册 5、VirtualDOM，Diff和Render UI实现 6、页面事件触发 在此基础上，AppView有一个html模板文件，通过这个模板文件加载具体的页面，这个模板主要就一个方法，$gwx，主要是返回指定page的VirtualDOM，而在打包的时候，会事先把所有页面的WXML转换为ViirtualDOM放到模板文件里，而微信自己写了2个工具wcc（把WXML转换为VirtualDOM）和wcsc（把WXSS转换为一个JS字符串的形式通过style标签append到header里）。 Service和View通信 使用消息publish和subscribe机制实现两个Webview之间的通信，实现方式就是统一封装一个WeixinJSBridge对象，而不同的环境封装的接口不一样，具体实现的技术如下： windows环境 通过window.postMessage实现（使用chrome扩展的接口注入一个contentScript.js，它封装了postMessage方法，实现webview之间的通信，并且也它通过chrome.runtime.connect方式，也提供了直接操作chrome native原生方法的接口） 发送消息：window.postMessage(data, ‘*’);，// data里指定 webviewID 接收消息：window.addEventListener(‘message’, messageHandler); // 消息处理并分发，同样支持调用nwjs的原生能力。 在contentScript里面看到一句话，证实了appservice也是通过一个webview实现的，实现原理上跟view一样，只是处理的业务逻辑不一样。 'webframe' === b ? postMessageToWebPage(a) : 'appservice' === b &amp;&amp; postMessageToWebPage(a)1 IOS 通过 WKWebview的window.webkit.messageHandlers.NAME.postMessage实现微信navite代码里实现了两个handler消息处理器： invokeHandler: 调用原生能力 publishHandler: 消息分发 Android 通过WeixinJSCore.invokeHanlder实现，这个WeixinJSCore是微信提供给JS调用的接口（native实现） invokeHandler: 调用原生能力 publishHandler: 消息分发 微信组件 在WAWebview.js里有个对象叫exparser，它完整的实现小程序里的组件，看具体的实现方式，思路上跟w3c的web components规范神似，但是具体实现上是不一样的，我们使用的所有组件，都会被提前注册好，在Webview里渲染的时候进行替换组装。 exparser有个核心方法： regiisterBehavior: 注册组件的一些基础行为，供组件继承 registerElement：注册组件，跟我们交互接口主要是属性和事件 组件触发事件（带上webviewID），调用WeixinJSBridge的接口，publish到native，然后native再分发到AppService层指定webviewID的Page注册事件处理方法。 总结 小程序底层还是基于Webview来实现的，并没有发明创造新技术，整个框架体系，比较清晰和简单，基于Web规范，保证现有技能价值的最大化，只需了解框架规范即可使用已有Web技术进行开发。易于理解和开发。 MSSM：对逻辑和UI进行了完全隔离，这个跟当前流行的react，agular，vue有本质的区别，小程序逻辑和UI完全运行在2个独立的Webview里面，而后面这几个框架还是运行在一个webview里面的，如果你想，还是可以直接操作dom对象，进行ui渲染的。 组件机制：引入组件化机制，但是不完全基于组件开发，跟vue一样大部分UI还是模板化渲染，引入组件机制能更好的规范开发模式，也更方便升级和维护。 多种节制：不能同时打开超过5个窗口，打包文件不能大于1M，dom对象不能大于16000个等，这些都是为了保证更好的体验。]]></content>
      <categories>
        <category>作业</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[error about mathtype in word2016]]></title>
    <url>%2Fpost%2Ferror-about-mathtype-in-word2016(1).html</url>
    <content type="text"><![CDATA[前言：一不小心，不知为什么打开word的时候mathtype报错，报错的截图如下（话说为了它，我还故意复原了一下这个error！），之前没得空也就没理他，这两天有时间了当然得治治它咯！走你！ 截图在这里： 下面进入正文 先说一下原因，比较简单，这个错误的根源就是”word2016的加载项里少了一个mathtype必需的文件MathPage.wll“，这个文件在mathtype的安装位置下，以我的电脑为例，可以在D:\Mathtype6.9d\MathPage\64中找到它，这个安装位置不是固定的，是每个人的电脑而定不过可以借鉴一下这个地址格式! 上刑具，哦，不是，上方案！根据如下两篇百度知道文章第一篇、该文章不适用但可借鉴，第二篇、解决关键,再经过自己一番测试，结论如下，将第一步中找到的文件复制到C:\Software\Office\Office16然后重启word即可解决该问题，弹窗再也没有了！Ps：第二步中的地址可以在word里的”加载项“设置页面里找到！]]></content>
      <categories>
        <category>office</category>
      </categories>
      <tags>
        <tag>word2016&amp;error-solve</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win10环境下配置hexo博客(2)]]></title>
    <url>%2Fpost%2Fwin10-hexo-install-set-2.html</url>
    <content type="text"></content>
      <categories>
        <category>grocery</category>
      </categories>
      <tags>
        <tag>hexo&amp;win10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[post自动生成格式的测试样例]]></title>
    <url>%2Fpost%2Ftest%20of%20post.md.html</url>
    <content type="text"></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win10环境下配置hexo博客(1)]]></title>
    <url>%2Fpost%2Fwin10-hexo-install-set-1.html</url>
    <content type="text"><![CDATA[安装环境为win10-1809版本，主要完成了hexo博客的安装、更换主题为maupassant、配置gitalk评论系统、设置网站menu和旁边控件widget、设置永久链接（未使用插件）、实现front-matter的自动设置等工作！ 一、windows环境下hexo博客的部署​ 配置环境属于机械式的，找到教程刷刷就完了，这是第二次部署了，结果因为之前没有留好标记，搞得第二回又是一通chrome！很烦！ 所以现在就把这一回的东西都mark在这！同时，立个flag, 这一回我要好好经营我这个博客，起码得两天一更！ 首先就找hexo官网咯! 文档很详细，小白上手的话还要参照一下其他教程如：前期安装教程, 以及github部署教程的配置！，第二个链接更为详细，推荐！ 总结如下： 安装git和node.js，做好git的相应配置（node.js我没动！） npm install -g hexo-cli 命令安装hexo！推荐在shell中切换到blog的本地目录之后再操作，npm可以理解成一个模块or扩展管理器，模块安装位置似乎默认为当前文件夹！ 切换到新建的blog（本地目录）文件夹，然后使用下面的命令： hexo init npm install 也可以使用hexo init &lt;folder’s name&gt;命令来新建一个文件再cd进入在文件然后再使用上面第二条命令！ 保持当前工作目录为blog，运行hexo server命令后打开本地端口网址 查看效果，我一般用这种方法来测试效果! 部署到github上！ 这一步需要先在github上创建一个新的仓库，名字格式有要求，须为username.github.io格式！，然后进行ssh设置并更改_config.yml文件，具体更改为在type子项后键入git，在repo子项后输入自己github仓库的地址（形如https://github.com/username/username.github.io.git）， 在branch子项后加上master即可，注意冒号后面要留空格（这是yml文件的格式要求）！之后在powershell中敲入 hexo generate(=hexo g), hexo deploy(= hexo d) 命令，稍等一下之后打开自己博客的网址，注意更改username为自己的用户名，如果看到网页上的东西和第四步中的内容一样就OK啦！ repo子项在某些教程中也可以使用`git@github.com:username/username.github.io`的形式（我用了这个），上面那种格式我没有测试，望知悉！ 碰到的几个错误：1、部署到github时发现报错‘ERROR Deployer not found: github’，解决方法参考了这篇文章 总结一下呢，就是缺了一个必要的插件：hexo-deployer-git; 解决方法也很简单：npm install hexo-deployer-git --save 命令即可，注意需要在第五步之前操作，这个坑是出现在第一个教程链接里，里面没说明，但第二个教程注明了！ markdown软件的选择 之前有使用过markdownpad，后来重装系统后到现在才重新设置hexo博客，typora可以选择主题，所以就换成了该软件，不过主题好像只在typora中有效，网页端效果还是默认的！猜测要达成主题一致的效果需要改动hexo的配置文件！ 发现typora很是奇怪，用它生成的一个markdown文档始终不能部署deploy成功，更换软件查看源文档之后，我推测这应该属于软件本身和hexo的兼容问题，没得法子，又换成了markdownpad，虽然UI上不及typora但功能上却胜过它！ 这里贴一个markdownpad2的注册码吧，软件需要注册不过嘛，嘿嘿！MarkdownPad2.5注册码 更换成maupassant主题 一番百度之后，找到了一个很对自己胃口的主题也就是maupassant，主题是大佬二次开发的，作者的博客里面介绍得很详细，从安装到设置都很详细！我就不再赘述了，详情参照链接！ 二、博客的优化以及调整 首先呢，根据主题（我使用的是maupassant！）的说明，默认显示的摘要是文档的第一段，几乎绝大多数情况下产生的摘要都很凌乱，更别提能够帮助掌握文章的主旨与脉络咯！所以，摘要一定得自己亲力亲为！ 设置摘要有两种方式，第一种，直接在front-matter中插入一段description，如下所示： xxx description: testing第二种方法就是在front-matter后面写一段文字，然后加上如下代码&lt;!--more--&gt;即可，这样处于front-matter和该行代码中间的部分就是description了！ 比较两种方法，经过实际操作之后，墙裂推荐第二种，因为摘要一般都有好几行，而front-matter并不支持代码换行输入（我不知道），直接敲几行的description的话在博客generate和deploy环节会报错！综上，老实用第二种方法吧！别跳进第一个方法的坑了！powershell的报错示意图如下: maupassant默认的界面需要优化一下，主要操作是去掉rss，设置about项目，设置时有参考这篇文章，我自己做了相应的改进，总结如下： hexo new page about 在主题的config.yml文件中修改，备注掉rss项，添加自定义项！自定义项待测试！ 在hexo博客根目录下的/source/about中可以发现index.md文件，做相应修改即可实现about界面的自定义！ maupassant默认设置为首页上方有“首页、归档、关于、订阅“四个栏目（menu），可以自己订制menu！关于设置menu中文显示、条目目录、’post自动生成格式的修改‘的技巧可以参考本文，在引用的这篇文章中使用的主题并不是maupassant，所以hexo new page grocery&lt;参考而已&gt;命令之后还需要自己手动配置/source/grocery/index.md文件，否则的话点击之后出来的页面只是一片空白，自己不懂这一方面，所以要深度自定义的话还得留待日后！大致看了一下，我想做的”杂项“menu可以参考自带的归档文件，先mark一下！ 博客中添加图片、音乐、视频素材！一篇文章或者报告内容质量是至高准则，但版面的美观简练也不容忽视，有些时候多媒体资料的表现力是无法为文字所替代的！ 主要目标： 图片大小可以自己定义、图片能够设置居中等格式、图片上传方便有序；视频可以调整播放进度条、视频宽高及居中等设置、可以点击重新播放及记忆播放进度；音乐与视频近似！ 1)根据这篇文章，设置图片居左/居中/居右的方法为： &lt;div align=center&gt;![这里写图片描述](http:...) -居中 &lt;div align=right&gt;![这里写图片描述](http:...) -居右 [这里写图片描述](http:...) -默认为居左 这里以一张图片为例，图源为bing搜索！ 居左: &lt;img src=&quot;http://www.wuxubj.cn/images/avatar.jpg&quot; width = &quot;100&quot; height = &quot;100&quot; div align=left alt=&quot;markdown图片插入的最佳方式&quot; /&gt; 居中： 居右： &lt;img src=&quot;http://www.wuxubj.cn/images/avatar.jpg&quot; width = &quot;100&quot; height = &quot;100&quot; div align=right alt=&quot;markdown图片插入的最佳方式&quot; /&gt; 个人最为推荐的方式是采用html图片嵌入的方法，具体的html语法可以参考这里，实际上写markdown文档的话只需要记忆上面的例子即可！图片的提示文字无法固定在图片正下方！设置方法留待验证！另外，经过测试，markdownpad自带的图传已经失效，不知是软件未更新还是什么的原因。 2)在hexo博客中插入音频和视频的方法：第一种就是采用html内嵌代码，原理几乎和插入图片一致，都是html的神奇用法，效果可以参见下方的B站视频；第二种即使用相关插件 B站视频html方式插入的代码如下： &lt;iframe src=&quot;//player.bilibili.com/player.html?aid=9584304&amp;cid=15841366&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt; 结果在这里(没想到吧，是瞎看哦!)：]]></content>
      <categories>
        <category>grocery</category>
      </categories>
      <tags>
        <tag>hexo&amp;win10</tag>
      </tags>
  </entry>
</search>
